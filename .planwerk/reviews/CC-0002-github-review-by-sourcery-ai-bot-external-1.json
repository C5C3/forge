{
  "feature_id": "CC-0002",
  "title": "GitHub Review by sourcery-ai[bot]",
  "summary": "Hey - I've found 3 issues, and left some high level feedback:\n\n- SimulateExternalSecretSync always creates the target Secret with the same name/namespace as the ExternalSecret and ignores spec.target.name, which may not match real-world manifests and could make tests diverge from production behaviour; consider reading the target name from the ExternalSecret spec (with a sensible default) before creating the Secret.\n- The envtest setup helpers (FakeCRDsPath/fakeCRDSubDirs/SetupEnvTest) panic on filesystem or startup errors, which can make diagnosing misconfiguration harder in larger suites; consider returning errors (or testing.T helpers) instead so callers can fail tests with clearer, contextual messages or selectively skip when CRDs/env binaries are missing.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- SimulateExternalSecretSync always creates the target Secret with the same name/namespace as the ExternalSecret and ignores spec.target.name, which may not match real-world manifests and could make tests diverge from production behaviour; consider reading the target name from the ExternalSecret spec (with a sensible default) before creating the Secret.\n- The envtest setup helpers (FakeCRDsPath/fakeCRDSubDirs/SetupEnvTest) panic on filesystem or startup errors, which can make diagnosing misconfiguration harder in larger suites; consider returning errors (or testing.T helpers) instead so callers can fail tests with clearer, contextual messages or selectively skip when CRDs/env binaries are missing.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"internal/common/testutil/simulators/externalsecret.go\" line_range=\"58\" />\n<code_context>\n+\tscheme := runtime.NewScheme()\n+\t_ = corev1.AddToScheme(scheme)\n+\n+\tsecret := &corev1.Secret{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test-secret\",\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** SimulateExternalSecretSync does not update an existing target Secret‚Äôs data, making it non-idempotent for content changes.\n\nBecause the helper only creates the Secret and ignores AlreadyExists, repeated calls (or pre-created Secrets) won‚Äôt reconcile the data to `targetSecretData`, so the Secret can diverge from the ExternalSecret status. To make this helper idempotent and closer to real controller behavior, handle AlreadyExists by fetching the existing Secret and updating/patching its `Data` field to match `targetSecretData`.\n</issue_to_address>\n\n### Comment 2\n<location path=\"internal/common/testutil/simulators/simulators_integration_test.go\" line_range=\"217-34\" />\n<code_context>\n+\t}\n+}\n+\n+func TestSimulateExternalSecretSync_Idempotent(t *testing.T) {\n+\tctx := context.Background()\n+\tname := \"test-externalsecret-idempotent\"\n+\tnamespace := \"test-simulators\"\n+\n+\ttargetData := map[string][]byte{\n+\t\t\"username\": []byte(\"admin\"),\n+\t\t\"password\": []byte(\"s3cret\"),\n+\t}\n+\n+\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Strengthen idempotency test for SimulateExternalSecretSync by asserting final state\n\nRight now this only verifies that calling `SimulateExternalSecretSync` twice doesn‚Äôt error. To more fully test idempotency, after the second call fetch the ExternalSecret and Secret and assert that the Ready=True condition is still set and the Secret data still equals `targetData`. This will help catch regressions where subsequent calls inadvertently clear or mutate state.\n\nSuggested implementation:\n\n```golang\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Second invocation should also succeed and leave the ExternalSecret/Secret\n\t// in the same Ready state with the same data (idempotency).\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"second SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Verify ExternalSecret CR status is still Ready=True.\n\tes := &unstructured.Unstructured{}\n\tes.SetGroupVersionKind(schema.GroupVersionKind{\n\t\tGroup:   \"external-secrets.io\",\n\t\tVersion: \"v1beta1\",\n\t\tKind:    \"ExternalSecret\",\n\t})\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, es); err != nil {\n\t\tt.Fatalf(\"failed to get ExternalSecret after second sync: %v\", err)\n\t}\n\n\tconditions, found, err := unstructured.NestedSlice(es.Object, \"status\", \"conditions\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to read ExternalSecret status.conditions: %v\", err)\n\t}\n\tif !found || len(conditions) == 0 {\n\t\tt.Fatalf(\"ExternalSecret status.conditions is empty after second sync\")\n\t}\n\n\treadyFound := false\n\tfor _, condRaw := range conditions {\n\t\tcondMap, ok := condRaw.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tcondType, _ := condMap[\"type\"].(string)\n\t\tif condType != \"Ready\" {\n\t\t\tcontinue\n\t\t}\n\t\treadyFound = true\n\t\tstatus, _ := condMap[\"status\"].(string)\n\t\tif status != \"True\" {\n\t\t\tt.Fatalf(\"ExternalSecret Ready condition is not True after second sync, got %q\", status)\n\t\t}\n\t}\n\tif !readyFound {\n\t\tt.Fatalf(\"ExternalSecret Ready condition not found after second sync\")\n\t}\n\n\t// Verify Secret data is still equal to targetData after the second sync.\n\tsecret := &corev1.Secret{}\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, secret); err != nil {\n\t\tt.Fatalf(\"failed to get Secret after second sync: %v\", err)\n\t}\n\n\tfor key, expectedVal := range targetData {\n\t\tactualVal, ok := secret.Data[key]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected key %q in Secret data after second sync, but not found\", key)\n\t\t}\n\t\tif string(actualVal) != string(expectedVal) {\n\t\t\tt.Fatalf(\"Secret data[%q] after second sync: expected %q, got %q\", key, expectedVal, actualVal)\n\t\t}\n\t}\n\n```\n\nTo compile successfully, ensure the following imports are present at the top of `simulators_integration_test.go` (some may already exist from other tests):\n\n- `corev1 \"k8s.io/api/core/v1\"`\n- `\"k8s.io/apimachinery/pkg/types\"`\n\nIf these imports are missing, add them to the existing import block, keeping the current style and grouping consistent with the rest of the file.\n</issue_to_address>\n\n### Comment 3\n<location path=\"internal/common/testutil/envtest/setup_test.go\" line_range=\"8-14\" />\n<code_context>\n+\t\"testing\"\n+)\n+\n+func TestFakeCRDsPath_ReturnsExistingDirectory(t *testing.T) {\n+\tpath := FakeCRDsPath()\n+\n+\tinfo, err := os.Stat(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FakeCRDsPath() returned %q, which does not exist: %v\", path, err)\n+\t}\n+\tif !info.IsDir() {\n+\t\tt.Fatalf(\"FakeCRDsPath() returned %q, which is not a directory\", path)\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Consider adding tests for fakeCRDSubDirs to ensure CRD subdirectory discovery remains correct\n\nSince `SetupEnvTest` depends on `fakeCRDSubDirs` to discover CRD directories, it‚Äôd be helpful to add a unit test here that calls `fakeCRDSubDirs()`, asserts the slice is non-empty, and verifies each returned path exists and is a directory. This gives a faster failure signal than relying on integration tests if the fake CRD layout changes.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>",
  "verdict": "ADDRESSED",
  "tests_checklist": [],
  "code_quality_checklist": [],
  "security_checklist": [],
  "architecture_checklist": [],
  "dry_yagni_checklist": [],
  "fail_fast_checklist": [],
  "defensive_checklist": [],
  "security_findings": [],
  "architecture_findings": [],
  "issues_found": [],
  "suggested_improvements": [],
  "next_steps": [],
  "reviewer": "sourcery-ai[bot]",
  "date": "2026-03-01T08:49:29Z",
  "commit_reference": "",
  "review_type": "external",
  "sequence_number": 1,
  "external_feedback": "Hey - I've found 3 issues, and left some high level feedback:\n\n- SimulateExternalSecretSync always creates the target Secret with the same name/namespace as the ExternalSecret and ignores spec.target.name, which may not match real-world manifests and could make tests diverge from production behaviour; consider reading the target name from the ExternalSecret spec (with a sensible default) before creating the Secret.\n- The envtest setup helpers (FakeCRDsPath/fakeCRDSubDirs/SetupEnvTest) panic on filesystem or startup errors, which can make diagnosing misconfiguration harder in larger suites; consider returning errors (or testing.T helpers) instead so callers can fail tests with clearer, contextual messages or selectively skip when CRDs/env binaries are missing.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- SimulateExternalSecretSync always creates the target Secret with the same name/namespace as the ExternalSecret and ignores spec.target.name, which may not match real-world manifests and could make tests diverge from production behaviour; consider reading the target name from the ExternalSecret spec (with a sensible default) before creating the Secret.\n- The envtest setup helpers (FakeCRDsPath/fakeCRDSubDirs/SetupEnvTest) panic on filesystem or startup errors, which can make diagnosing misconfiguration harder in larger suites; consider returning errors (or testing.T helpers) instead so callers can fail tests with clearer, contextual messages or selectively skip when CRDs/env binaries are missing.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"internal/common/testutil/simulators/externalsecret.go\" line_range=\"58\" />\n<code_context>\n+\tscheme := runtime.NewScheme()\n+\t_ = corev1.AddToScheme(scheme)\n+\n+\tsecret := &corev1.Secret{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test-secret\",\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** SimulateExternalSecretSync does not update an existing target Secret‚Äôs data, making it non-idempotent for content changes.\n\nBecause the helper only creates the Secret and ignores AlreadyExists, repeated calls (or pre-created Secrets) won‚Äôt reconcile the data to `targetSecretData`, so the Secret can diverge from the ExternalSecret status. To make this helper idempotent and closer to real controller behavior, handle AlreadyExists by fetching the existing Secret and updating/patching its `Data` field to match `targetSecretData`.\n</issue_to_address>\n\n### Comment 2\n<location path=\"internal/common/testutil/simulators/simulators_integration_test.go\" line_range=\"217-34\" />\n<code_context>\n+\t}\n+}\n+\n+func TestSimulateExternalSecretSync_Idempotent(t *testing.T) {\n+\tctx := context.Background()\n+\tname := \"test-externalsecret-idempotent\"\n+\tnamespace := \"test-simulators\"\n+\n+\ttargetData := map[string][]byte{\n+\t\t\"username\": []byte(\"admin\"),\n+\t\t\"password\": []byte(\"s3cret\"),\n+\t}\n+\n+\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Strengthen idempotency test for SimulateExternalSecretSync by asserting final state\n\nRight now this only verifies that calling `SimulateExternalSecretSync` twice doesn‚Äôt error. To more fully test idempotency, after the second call fetch the ExternalSecret and Secret and assert that the Ready=True condition is still set and the Secret data still equals `targetData`. This will help catch regressions where subsequent calls inadvertently clear or mutate state.\n\nSuggested implementation:\n\n```golang\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Second invocation should also succeed and leave the ExternalSecret/Secret\n\t// in the same Ready state with the same data (idempotency).\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"second SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Verify ExternalSecret CR status is still Ready=True.\n\tes := &unstructured.Unstructured{}\n\tes.SetGroupVersionKind(schema.GroupVersionKind{\n\t\tGroup:   \"external-secrets.io\",\n\t\tVersion: \"v1beta1\",\n\t\tKind:    \"ExternalSecret\",\n\t})\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, es); err != nil {\n\t\tt.Fatalf(\"failed to get ExternalSecret after second sync: %v\", err)\n\t}\n\n\tconditions, found, err := unstructured.NestedSlice(es.Object, \"status\", \"conditions\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to read ExternalSecret status.conditions: %v\", err)\n\t}\n\tif !found || len(conditions) == 0 {\n\t\tt.Fatalf(\"ExternalSecret status.conditions is empty after second sync\")\n\t}\n\n\treadyFound := false\n\tfor _, condRaw := range conditions {\n\t\tcondMap, ok := condRaw.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tcondType, _ := condMap[\"type\"].(string)\n\t\tif condType != \"Ready\" {\n\t\t\tcontinue\n\t\t}\n\t\treadyFound = true\n\t\tstatus, _ := condMap[\"status\"].(string)\n\t\tif status != \"True\" {\n\t\t\tt.Fatalf(\"ExternalSecret Ready condition is not True after second sync, got %q\", status)\n\t\t}\n\t}\n\tif !readyFound {\n\t\tt.Fatalf(\"ExternalSecret Ready condition not found after second sync\")\n\t}\n\n\t// Verify Secret data is still equal to targetData after the second sync.\n\tsecret := &corev1.Secret{}\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, secret); err != nil {\n\t\tt.Fatalf(\"failed to get Secret after second sync: %v\", err)\n\t}\n\n\tfor key, expectedVal := range targetData {\n\t\tactualVal, ok := secret.Data[key]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected key %q in Secret data after second sync, but not found\", key)\n\t\t}\n\t\tif string(actualVal) != string(expectedVal) {\n\t\t\tt.Fatalf(\"Secret data[%q] after second sync: expected %q, got %q\", key, expectedVal, actualVal)\n\t\t}\n\t}\n\n```\n\nTo compile successfully, ensure the following imports are present at the top of `simulators_integration_test.go` (some may already exist from other tests):\n\n- `corev1 \"k8s.io/api/core/v1\"`\n- `\"k8s.io/apimachinery/pkg/types\"`\n\nIf these imports are missing, add them to the existing import block, keeping the current style and grouping consistent with the rest of the file.\n</issue_to_address>\n\n### Comment 3\n<location path=\"internal/common/testutil/envtest/setup_test.go\" line_range=\"8-14\" />\n<code_context>\n+\t\"testing\"\n+)\n+\n+func TestFakeCRDsPath_ReturnsExistingDirectory(t *testing.T) {\n+\tpath := FakeCRDsPath()\n+\n+\tinfo, err := os.Stat(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FakeCRDsPath() returned %q, which does not exist: %v\", path, err)\n+\t}\n+\tif !info.IsDir() {\n+\t\tt.Fatalf(\"FakeCRDsPath() returned %q, which is not a directory\", path)\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Consider adding tests for fakeCRDSubDirs to ensure CRD subdirectory discovery remains correct\n\nSince `SetupEnvTest` depends on `fakeCRDSubDirs` to discover CRD directories, it‚Äôd be helpful to add a unit test here that calls `fakeCRDSubDirs()`, asserts the slice is non-empty, and verifies each returned path exists and is a directory. This gives a faster failure signal than relying on integration tests if the fake CRD layout changes.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>",
  "code_comments": [
    {
      "body": "**suggestion (bug_risk):** SimulateExternalSecretSync does not update an existing target Secret‚Äôs data, making it non-idempotent for content changes.\n\nBecause the helper only creates the Secret and ignores AlreadyExists, repeated calls (or pre-created Secrets) won‚Äôt reconcile the data to `targetSecretData`, so the Secret can diverge from the ExternalSecret status. To make this helper idempotent and closer to real controller behavior, handle AlreadyExists by fetching the existing Secret and updating/patching its `Data` field to match `targetSecretData`.",
      "path": "internal/common/testutil/simulators/externalsecret.go",
      "line": 58,
      "author": "sourcery-ai[bot]",
      "created_at": "2026-03-01T08:49:30Z",
      "id": null
    },
    {
      "body": "**suggestion (testing):** Strengthen idempotency test for SimulateExternalSecretSync by asserting final state\n\nRight now this only verifies that calling `SimulateExternalSecretSync` twice doesn‚Äôt error. To more fully test idempotency, after the second call fetch the ExternalSecret and Secret and assert that the Ready=True condition is still set and the Secret data still equals `targetData`. This will help catch regressions where subsequent calls inadvertently clear or mutate state.\n\nSuggested implementation:\n\n```golang\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Second invocation should also succeed and leave the ExternalSecret/Secret\n\t// in the same Ready state with the same data (idempotency).\n\tif err := simulators.SimulateExternalSecretSync(ctx, k8sClient, name, namespace, targetData); err != nil {\n\t\tt.Fatalf(\"second SimulateExternalSecretSync returned error: %v\", err)\n\t}\n\n\t// Verify ExternalSecret CR status is still Ready=True.\n\tes := &unstructured.Unstructured{}\n\tes.SetGroupVersionKind(schema.GroupVersionKind{\n\t\tGroup:   \"external-secrets.io\",\n\t\tVersion: \"v1beta1\",\n\t\tKind:    \"ExternalSecret\",\n\t})\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, es); err != nil {\n\t\tt.Fatalf(\"failed to get ExternalSecret after second sync: %v\", err)\n\t}\n\n\tconditions, found, err := unstructured.NestedSlice(es.Object, \"status\", \"conditions\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to read ExternalSecret status.conditions: %v\", err)\n\t}\n\tif !found || len(conditions) == 0 {\n\t\tt.Fatalf(\"ExternalSecret status.conditions is empty after second sync\")\n\t}\n\n\treadyFound := false\n\tfor _, condRaw := range conditions {\n\t\tcondMap, ok := condRaw.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tcondType, _ := condMap[\"type\"].(string)\n\t\tif condType != \"Ready\" {\n\t\t\tcontinue\n\t\t}\n\t\treadyFound = true\n\t\tstatus, _ := condMap[\"status\"].(string)\n\t\tif status != \"True\" {\n\t\t\tt.Fatalf(\"ExternalSecret Ready condition is not True after second sync, got %q\", status)\n\t\t}\n\t}\n\tif !readyFound {\n\t\tt.Fatalf(\"ExternalSecret Ready condition not found after second sync\")\n\t}\n\n\t// Verify Secret data is still equal to targetData after the second sync.\n\tsecret := &corev1.Secret{}\n\tif err := k8sClient.Get(ctx, types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t}, secret); err != nil {\n\t\tt.Fatalf(\"failed to get Secret after second sync: %v\", err)\n\t}\n\n\tfor key, expectedVal := range targetData {\n\t\tactualVal, ok := secret.Data[key]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected key %q in Secret data after second sync, but not found\", key)\n\t\t}\n\t\tif string(actualVal) != string(expectedVal) {\n\t\t\tt.Fatalf(\"Secret data[%q] after second sync: expected %q, got %q\", key, expectedVal, actualVal)\n\t\t}\n\t}\n\n```\n\nTo compile successfully, ensure the following imports are present at the top of `simulators_integration_test.go` (some may already exist from other tests):\n\n- `corev1 \"k8s.io/api/core/v1\"`\n- `\"k8s.io/apimachinery/pkg/types\"`\n\nIf these imports are missing, add them to the existing import block, keeping the current style and grouping consistent with the rest of the file.",
      "path": "internal/common/testutil/simulators/simulators_integration_test.go",
      "line": 34,
      "author": "sourcery-ai[bot]",
      "created_at": "2026-03-01T08:49:30Z",
      "id": null
    },
    {
      "body": "**suggestion (testing):** Consider adding tests for fakeCRDSubDirs to ensure CRD subdirectory discovery remains correct\n\nSince `SetupEnvTest` depends on `fakeCRDSubDirs` to discover CRD directories, it‚Äôd be helpful to add a unit test here that calls `fakeCRDSubDirs()`, asserts the slice is non-empty, and verifies each returned path exists and is a directory. This gives a faster failure signal than relying on integration tests if the fake CRD layout changes.",
      "path": "internal/common/testutil/envtest/setup_test.go",
      "line": 14,
      "author": "sourcery-ai[bot]",
      "created_at": "2026-03-01T08:49:30Z",
      "id": null
    }
  ]
}